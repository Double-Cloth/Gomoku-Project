<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport">
    <title>AI 五子棋</title>

    <script src="./libs/react.js"></script>
    <script src="./libs/react-dom.js"></script>
    <script src="./libs/babel.js"></script>
    <script src="./libs/tailwind.js"></script>

    <style>
        body {
            font-family: system-ui, -apple-system, "Microsoft YaHei", "Segoe UI", Roboto, sans-serif;
            background-color: #0F172A;
            background-image: radial-gradient(at 0% 0%, rgba(56, 189, 248, 0.1) 0px, transparent 50%),
            radial-gradient(at 100% 0%, rgba(236, 72, 153, 0.05) 0px, transparent 50%);
        }

        /* 棋子字体单独设置为等宽字体栈 */
        .piece {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        .coord-text {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
        }

        /* 棋盘纹理 */
        .board-texture {
            background-color: #EEBB66;
            background-image: linear-gradient(rgba(255, 255, 255, 0.15) 0%, rgba(0, 0, 0, 0.05) 100%),
            url("data:image/svg+xml,%3Csvg viewBox='0 0 400 400' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noiseFilter'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noiseFilter)' opacity='0.08'/%3E%3C/svg%3E");
            box-shadow: 0 20px 50px -12px rgba(0, 0, 0, 0.7),
            0 0 0 1px rgba(0, 0, 0, 0.4),
            inset 0 0 40px rgba(92, 64, 51, 0.3);
            border-radius: 4px;
        }

        /* 棋子样式 */
        .piece {
            width: 90%;
            height: 90%;
            border-radius: 50%;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.95);
            box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.6), inset -2px -2px 6px rgba(0, 0, 0, 0.2);
            transition: all 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 20;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: 700;
        }

        @media (max-width: 640px) {
            .piece {
                font-size: 9px;
            }
        }

        .piece-black {
            background: radial-gradient(circle at 35% 35%, #555 0%, #1A1A1A 30%, #000 100%);
            box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.7), inset 1px 1px 3px rgba(255, 255, 255, 0.15);
            color: rgba(255, 255, 255, 0.9);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.8);
        }

        .piece-white {
            background: radial-gradient(circle at 30% 30%, #FFF 0%, #F3F3F3 30%, #D1D1D1 100%);
            box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.4), inset -1px -1px 3px rgba(0, 0, 0, 0.1);
            color: rgba(0, 0, 0, 0.85);
        }

        .piece-enter {
            animation: dropIn 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards;
        }

        @keyframes dropIn {
            from {
                transform: translate(-50%, -50%) scale(1.4);
                opacity: 0;
            }
            to {
                transform: translate(-50%, -50%) scale(0.95);
                opacity: 1;
            }
        }

        /* 获胜棋子高亮 */
        .piece-win {
            box-shadow: 0 0 15px 2px rgba(74, 222, 128, 0.6), 2px 3px 5px rgba(0, 0, 0, 0.6) !important;
            z-index: 50 !important;
        }

        .glass-panel {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid rgba(255, 255, 255, 0.08);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }

        .coord-text {
            font-size: 10px;
            color: #5C4033;
            font-weight: 700;
            user-select: none;
        }

        /* 滚动条美化 */
        .custom-scrollbar::-webkit-scrollbar {
            width: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-track {
            background: rgba(0, 0, 0, 0.1);
        }

        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 4px;
        }

        .custom-scrollbar::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        /* 动画 */
        @keyframes pulse-ring {
            0% {
                box-shadow: 0 0 0 0 rgba(56, 189, 248, 0.4);
            }
            70% {
                box-shadow: 0 0 0 10px rgba(56, 189, 248, 0);
            }
            100% {
                box-shadow: 0 0 0 0 rgba(56, 189, 248, 0);
            }
        }

        .animate-pulse-ring {
            animation: pulse-ring 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }
    </style>
</head>
<body class="text-slate-100 min-h-screen flex flex-col">
<div class="flex-grow flex flex-col" id="root"></div>

<script id="game-logic">
    // --- 核心常量 ---
    const BOARD_SIZE = 15;
    const EMPTY_SLOT = 0;
    const PIECE_B = 1;
    const PIECE_W = 2;

    const SCORE_MAX = 9000000000000000;
    const SCORE_MIN = -9000000000000000;

    const SCORE_FIVE = 1111111111;
    const SCORE_FOUR_OPEN = 1100000;
    const SCORE_THREE_OPEN = 1100;
    const SCORE_FOUR_RUSH = 1000;
    const SCORE_JUMP_FOUR_OPEN = 1000;
    const SCORE_JUMP_THREE_OPEN = 900;
    const SCORE_JUMP_FOUR_SLEEP = 800;
    const SCORE_TWO_OPEN = 100;
    const SCORE_THREE_SLEEP = 100;
    const SCORE_TWO_SLEEP = 10;
    const SCORE_INVALID = 0;

    const PATTERN_WEIGHT = 1;

    const PATTERN_INVALID = 0;
    const PATTERN_TWO_SLEEP = 1;
    const PATTERN_TWO_OPEN = 2;
    const PATTERN_THREE_SLEEP = 3;
    const PATTERN_THREE_OPEN = 4;
    const PATTERN_FOUR_RUSH = 5;
    const PATTERN_FOUR_OPEN = 6;
    const PATTERN_FIVE = 7;
    const PATTERN_JUMP_THREE_OPEN = 8;
    const PATTERN_JUMP_FOUR_SLEEP = 9;
    const PATTERN_JUMP_FOUR_OPEN = 10;
    const PATTERN_COUNT = 11;

    const gDirectionRow = [1, 0, 1, 1];
    const gDirectionCol = [0, 1, 1, -1];

    const SEARCH_DEPTH = 7;

    const TT_SIZE = 1 << 20;
    const TT_TYPE_EXACT = 0;
    const TT_TYPE_ALPHA = 1;
    const TT_TYPE_BETA = 2;

    // --- 随机数生成 ---
    let gPrngState = BigInt("0xBADF00DDEADBEEF");

    function seedRand(seed) {
        gPrngState = BigInt(seed) || BigInt("0xBADF00DDEADBEEF");
    }

    function genU64Rand() {
        gPrngState ^= gPrngState >> 12n;
        gPrngState ^= gPrngState << 25n;
        gPrngState ^= gPrngState >> 27n;
        return (gPrngState * 2685821657736338717n) & 0xFFFFFFFFFFFFFFFFn;
    }

    // --- AI 引擎类 ---
    class GameEngine {
        constructor() {
            this.board = Array(BOARD_SIZE).fill(0).map(() => Array(BOARD_SIZE).fill(0));
            this.currentHash = 0n;
            this.zobristKeys = null;
            this.tt = {
                keys: new BigInt64Array(TT_SIZE),
                scores: new Float64Array(TT_SIZE),
                depths: new Int8Array(TT_SIZE),
                types: new Uint8Array(TT_SIZE)
            };
            this.patternScores = {ai: new Float64Array(PATTERN_COUNT), opp: new Float64Array(PATTERN_COUNT)};
            this.aiPlayerId = 2;
            this.oppPlayerId = 1;
            this.init();
        }

        init() {
            seedRand(Date.now());
            this.zobristKeys = [];
            for (let p = 0; p < 3; p++) {
                let pieceLayer = [];
                for (let r = 0; r < BOARD_SIZE; r++) {
                    let rowLayer = [];
                    for (let c = 0; c < BOARD_SIZE; c++) {
                        rowLayer.push(genU64Rand());
                    }
                    pieceLayer.push(rowLayer);
                }
                this.zobristKeys.push(pieceLayer);
            }
            this.tt.keys.fill(0n);
            this.tt.scores.fill(0);
            this.tt.depths.fill(0);
            this.tt.types.fill(0);
            this.loadPatternScores();
            this.resetBoard();
        }

        loadPatternScores() {
            const ai = this.patternScores.ai;
            ai[PATTERN_FIVE] = SCORE_FIVE;
            ai[PATTERN_FOUR_OPEN] = SCORE_FOUR_OPEN;
            ai[PATTERN_THREE_OPEN] = SCORE_THREE_OPEN;
            ai[PATTERN_FOUR_RUSH] = SCORE_FOUR_RUSH;
            ai[PATTERN_JUMP_FOUR_OPEN] = SCORE_JUMP_FOUR_OPEN;
            ai[PATTERN_JUMP_THREE_OPEN] = SCORE_JUMP_THREE_OPEN;
            ai[PATTERN_JUMP_FOUR_SLEEP] = SCORE_JUMP_FOUR_SLEEP;
            ai[PATTERN_TWO_OPEN] = SCORE_TWO_OPEN;
            ai[PATTERN_THREE_SLEEP] = SCORE_THREE_SLEEP;
            ai[PATTERN_TWO_SLEEP] = SCORE_TWO_SLEEP;
            ai[PATTERN_INVALID] = SCORE_INVALID;

            const opp = this.patternScores.opp;
            for (let i = 0; i < PATTERN_COUNT; i++) {
                opp[i] = ai[i] * PATTERN_WEIGHT;
            }
        }

        resetBoard() {
            for (let r = 0; r < BOARD_SIZE; r++) {
                this.board[r].fill(EMPTY_SLOT);
            }
            this.currentHash = 0n;
        }

        // --- 同步棋盘状态 (Worker 专用) ---
        syncBoard(newBoard) {
            this.board = newBoard.map(row => [...row]);
            this.currentHash = 0n;
            for (let r = 0; r < BOARD_SIZE; r++) {
                for (let c = 0; c < BOARD_SIZE; c++) {
                    const piece = this.board[r][c];
                    if (piece !== EMPTY_SLOT) {
                        this.currentHash ^= this.zobristKeys[piece][r][c];
                    }
                }
            }
        }

        boardUpdate(r, c, piece) {
            const oldPiece = this.board[r][c];
            if (oldPiece !== EMPTY_SLOT) {
                this.currentHash ^= this.zobristKeys[oldPiece][r][c];
            }
            if (piece !== EMPTY_SLOT) {
                this.currentHash ^= this.zobristKeys[piece][r][c];
            }
            this.board[r][c] = piece;
        }

        ttSearch(depth, alpha, beta) {
            const index = Number(this.currentHash & BigInt(TT_SIZE - 1));
            if (this.tt.keys[index] === this.currentHash && this.tt.depths[index] >= depth) {
                const score = this.tt.scores[index];
                const type = this.tt.types[index];
                if (type === TT_TYPE_EXACT) {
                    return score;
                }
                if (type === TT_TYPE_ALPHA && score <= alpha) {
                    return alpha;
                }
                if (type === TT_TYPE_BETA && score >= beta) {
                    return beta;
                }
            }
            return SCORE_MIN - 1;
        }

        ttStore(depth, score, type) {
            const index = Number(this.currentHash & BigInt(TT_SIZE - 1));
            if (this.tt.depths[index] <= depth) {
                this.tt.keys[index] = this.currentHash;
                this.tt.depths[index] = depth;
                this.tt.scores[index] = score;
                this.tt.types[index] = type;
            }
        }

        searchDirection(posR, posC, dRow, dCol, player) {
            let result = {consecutiveCount: 0, openEnd: 0, jumpCount: 0, jumpOpen: 0, jumpBlocked: 0};
            const oppPlayer = player === 1 ? 2 : 1;
            let checkRow = posR + dRow;
            let checkCol = posC + dCol;
            let foundGap = false;
            let isJumping = false;

            while (checkRow >= 0 && checkRow < BOARD_SIZE && checkCol >= 0 && checkCol < BOARD_SIZE) {
                const cell = this.board[checkRow][checkCol];
                if (foundGap && !isJumping) {
                    if (cell === player) {
                        isJumping = true;
                        result.jumpCount++;
                    } else {
                        break;
                    }
                } else if (isJumping && foundGap) {
                    if (cell === player) {
                        result.jumpCount++;
                    } else if (cell === oppPlayer) {
                        result.jumpBlocked = 1;
                        break;
                    } else {
                        result.jumpOpen = 1;
                        break;
                    }
                } else {
                    if (cell === EMPTY_SLOT) {
                        result.openEnd = 1;
                        foundGap = true;
                    } else if (cell !== player) {
                        break;
                    } else {
                        result.consecutiveCount++;
                    }
                }
                checkRow += dRow;
                checkCol += dCol;
            }
            return result;
        }

        analyzeLine(posR, posC, dRow, dCol, player) {
            const fwd = this.searchDirection(posR, posC, dRow, dCol, player);
            const bwd = this.searchDirection(posR, posC, -dRow, -dCol, player);
            const consecutiveCount = fwd.consecutiveCount + bwd.consecutiveCount + 1;
            const openEnds = (fwd.openEnd ? 1 : 0) + (bwd.openEnd ? 2 : 0);

            if (fwd.jumpCount > 0 && bwd.jumpCount === 0) {
                const total = consecutiveCount + fwd.jumpCount;
                if (total === 3 && openEnds === 3 && fwd.jumpOpen) {
                    return PATTERN_JUMP_THREE_OPEN;
                }
                if (total === 4 && openEnds === 3 && fwd.jumpBlocked) {
                    return PATTERN_JUMP_FOUR_SLEEP;
                }
                if (total === 4 && openEnds === 1 && fwd.jumpOpen) {
                    return PATTERN_JUMP_FOUR_SLEEP;
                }
                if (total === 4 && openEnds === 3 && fwd.jumpOpen) {
                    return PATTERN_JUMP_FOUR_OPEN;
                }
            } else if (bwd.jumpCount > 0 && fwd.jumpCount === 0) {
                const total = consecutiveCount + bwd.jumpCount;
                if (total === 3 && openEnds === 3 && bwd.jumpOpen) {
                    return PATTERN_JUMP_THREE_OPEN;
                }
                if (total === 4 && openEnds === 3 && bwd.jumpBlocked) {
                    return PATTERN_JUMP_FOUR_SLEEP;
                }
                if (total === 4 && openEnds === 2 && bwd.jumpOpen) {
                    return PATTERN_JUMP_FOUR_SLEEP;
                }
                if (total === 4 && openEnds === 3 && bwd.jumpOpen) {
                    return PATTERN_JUMP_FOUR_OPEN;
                }
            }

            if (consecutiveCount >= 5) {
                return PATTERN_FIVE;
            }
            if (consecutiveCount === 4) {
                if (openEnds === 3) {
                    return PATTERN_FOUR_OPEN;
                }
                if (openEnds > 0) {
                    return PATTERN_FOUR_RUSH;
                }
            }
            if (consecutiveCount === 3) {
                if (openEnds === 3) {
                    return PATTERN_THREE_OPEN;
                }
                if (openEnds > 0) {
                    return PATTERN_THREE_SLEEP;
                }
            }
            if (consecutiveCount === 2) {
                if (openEnds === 3) {
                    return PATTERN_TWO_OPEN;
                }
                if (openEnds > 0) {
                    return PATTERN_TWO_SLEEP;
                }
            }
            return PATTERN_INVALID;
        }

        getPlayerThreat(posR, posC, player) {
            let totalScore = 0;
            for (let i = 0; i < 4; i++) {
                const pattern = this.analyzeLine(posR, posC, gDirectionRow[i], gDirectionCol[i], player);
                totalScore += this.patternScores.ai[pattern];
            }
            if (totalScore >= 1500 && totalScore < 1000000) {
                totalScore = 1000000;
            }
            return totalScore;
        }

        getPositionHeuristic(posR, posC) {
            let aiScore = 0;
            let oppScore = 0;
            for (let i = 0; i < 4; i++) {
                this.board[posR][posC] = this.aiPlayerId;
                const aiPattern = this.analyzeLine(posR, posC, gDirectionRow[i], gDirectionCol[i], this.aiPlayerId);
                this.board[posR][posC] = EMPTY_SLOT;

                this.board[posR][posC] = this.oppPlayerId;
                const oppPattern = this.analyzeLine(posR, posC, gDirectionRow[i], gDirectionCol[i], this.oppPlayerId);
                this.board[posR][posC] = EMPTY_SLOT;

                aiScore += this.patternScores.ai[aiPattern];
                oppScore += this.patternScores.opp[oppPattern];
            }
            if (oppScore >= 1500 && oppScore < 1000000) {
                oppScore = 1000000;
            }
            if (aiScore >= 1500 && aiScore < 1000000) {
                aiScore = 1000000;
            }
            return aiScore + oppScore;
        }

        evaluateBoardScore() {
            let aiTotal = 0;
            let oppTotal = 0;
            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (this.board[i][j] === this.aiPlayerId) {
                        aiTotal += this.getPlayerThreat(i, j, this.aiPlayerId);
                    } else if (this.board[i][j] === this.oppPlayerId) {
                        oppTotal += this.getPlayerThreat(i, j, this.oppPlayerId);
                    }
                }
            }
            return aiTotal - oppTotal;
        }

        isNearPiece(r, c) {
            // 1. 保留 JS 版特有的开局逻辑：
            // 如果是第一手（空棋盘），限制在天元附近落子，避免 AI 乱下
            // (C 语言版不需要这个，因为它开局默认中心已经有 4 颗子了)
            if (this.currentHash === 0n) {
                const centerMin = Math.floor(BOARD_SIZE / 2) - 2;
                const centerMax = Math.floor(BOARD_SIZE / 2) + 2;
                return (r >= centerMin && r <= centerMax && c >= centerMin && c <= centerMax);
            }

            // 2. 移植 C 语言版的 "米字形" 搜索逻辑：
            // 定义 8 个方向：上下左右 + 4个斜向
            const directions = [
                [-1, 0], [1, 0], [0, -1], [0, 1],   // 上下左右
                [-1, -1], [-1, 1], [1, -1], [1, 1]  // 左上, 右上, 左下, 右下
            ];

            // 遍历 8 个方向
            for (let d = 0; d < 8; d++) {
                // 遍历距离 1 和 2
                for (let dist = 1; dist <= 2; dist++) {
                    const nr = r + directions[d][0] * dist;
                    const nc = c + directions[d][1] * dist;

                    // 边界检查
                    if (nr >= 0 && nr < BOARD_SIZE && nc >= 0 && nc < BOARD_SIZE) {
                        // 如果发现有棋子，返回 true
                        if (this.board[nr][nc] !== EMPTY_SLOT) {
                            return true;
                        }
                    }
                }
            }

            return false;
        }

        generateCandidates() {
            let candidates = [];
            let firstZero = true;

            for (let i = 0; i < BOARD_SIZE; i++) {
                for (let j = 0; j < BOARD_SIZE; j++) {
                    if (this.board[i][j] === EMPTY_SLOT && this.isNearPiece(i, j)) {
                        const hScore = this.getPositionHeuristic(i, j);
                        if (hScore === 0 && firstZero) {
                            candidates.push({r: i, c: j, score: hScore});
                            firstZero = false;
                        } else if (hScore > 0) {
                            candidates.push({r: i, c: j, score: hScore});
                        }
                    }
                }
            }
            candidates.sort((a, b) => b.score - a.score);
            if (candidates.length > 6) {
                candidates.length = 6;
            }
            return candidates;
        }

        alphaBeta(depth, alpha, beta, player, lastMove) {
            const hashVal = this.ttSearch(depth, alpha, beta);
            if (hashVal > SCORE_MIN - 1) {
                return hashVal;
            }

            if (player === this.aiPlayerId && lastMove) {
                if (this.getPlayerThreat(lastMove.r, lastMove.c, this.oppPlayerId) >= SCORE_FIVE) {
                    return SCORE_MIN + 1;
                }
            }
            if (player === this.oppPlayerId && lastMove) {
                if (this.getPlayerThreat(lastMove.r, lastMove.c, this.aiPlayerId) >= SCORE_FIVE) {
                    return SCORE_MAX - 1;
                }
            }

            if (depth === 0) {
                const score = this.evaluateBoardScore();
                this.ttStore(depth, score, TT_TYPE_EXACT);
                return score;
            }

            const candidates = this.generateCandidates();
            let hashType = TT_TYPE_ALPHA;

            if (candidates.length === 0) {
                const score = this.evaluateBoardScore();
                this.ttStore(depth, score, TT_TYPE_EXACT);
                return score;
            }

            let maxMinEval = player === this.aiPlayerId ? SCORE_MIN : SCORE_MAX;

            for (const move of candidates) {
                this.boardUpdate(move.r, move.c, player);
                const evalScore = this.alphaBeta(depth - 1, alpha, beta, player === this.aiPlayerId ? this.oppPlayerId : this.aiPlayerId, move);
                this.boardUpdate(move.r, move.c, EMPTY_SLOT);

                if (player === this.aiPlayerId) {
                    if (evalScore > maxMinEval) {
                        maxMinEval = evalScore;
                    }
                    if (evalScore > alpha) {
                        alpha = evalScore;
                        hashType = TT_TYPE_EXACT;
                    }
                } else {
                    if (evalScore < maxMinEval) {
                        maxMinEval = evalScore;
                    }
                    if (evalScore < beta) {
                        beta = evalScore;
                        hashType = TT_TYPE_EXACT;
                    }
                }

                if (beta <= alpha) {
                    hashType = player === this.aiPlayerId ? TT_TYPE_BETA : TT_TYPE_ALPHA;
                    break;
                }
            }

            this.ttStore(depth, maxMinEval, hashType);
            return maxMinEval;
        }

        determineNextPlay() {
            this.tt.keys.fill(0n);
            this.tt.scores.fill(0);
            this.tt.depths.fill(0);
            this.tt.types.fill(0);

            const candidates = this.generateCandidates();
            let bestScore = SCORE_MIN;
            let bestMove = candidates.length > 0 ? candidates[0] : null;

            for (const move of candidates) {
                this.boardUpdate(move.r, move.c, this.aiPlayerId);
                const score = this.alphaBeta(SEARCH_DEPTH, SCORE_MIN, SCORE_MAX, this.oppPlayerId, move);
                this.boardUpdate(move.r, move.c, EMPTY_SLOT);

                if (score > bestScore) {
                    bestScore = score;
                    bestMove = move;
                }
            }
            return bestMove;
        }

        checkWin(r, c, player) {
            return this.getPlayerThreat(r, c, player) >= SCORE_FIVE;
        }

        getWinningLine(r, c, player) {
            for (let i = 0; i < 4; i++) {
                let line = [{r, c}];
                const dr = gDirectionRow[i];
                const dc = gDirectionCol[i];
                let currR = r + dr;
                let currC = c + dc;
                while (currR >= 0 && currR < BOARD_SIZE && currC >= 0 && currC < BOARD_SIZE && this.board[currR][currC] === player) {
                    line.push({r: currR, c: currC});
                    currR += dr;
                    currC += dc;
                }
                currR = r - dr;
                currC = c - dc;
                while (currR >= 0 && currR < BOARD_SIZE && currC >= 0 && currC < BOARD_SIZE && this.board[currR][currC] === player) {
                    line.push({r: currR, c: currC});
                    currR -= dr;
                    currC -= dc;
                }
                if (line.length >= 5) {
                    return line;
                }
            }
            return [];
        }
    }

    const mainEngine = new GameEngine();
</script>

<script type="text/babel">

    // ==========================================
    // === 图标组件 ===
    // ==========================================
    const Icons = {
        User: ({size = 20, className}) => <svg className={className} width={size} height={size} viewBox="0 0 24 24"
                                               fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round"
                                               strokeLinejoin="round">
            <path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"/>
            <circle cx="12" cy="7" r="4"/>
        </svg>,
        Cpu: ({size = 20, className}) => <svg className={className} width={size} height={size} viewBox="0 0 24 24"
                                              fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round"
                                              strokeLinejoin="round">
            <rect x="4" y="4" width="16" height="16" rx="2"/>
            <rect x="9" y="9" width="6" height="6"/>
            <path d="M15 2v2"/>
            <path d="M15 20v2"/>
            <path d="M2 15h2"/>
            <path d="M2 9h2"/>
            <path d="M20 15h2"/>
            <path d="M20 9h2"/>
            <path d="M9 2v2"/>
            <path d="M9 20v2"/>
        </svg>,
        Refresh: ({size = 20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                       strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8"/>
            <path d="M21 3v5h-5"/>
            <path d="M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16"/>
            <path d="M8 16H3v5"/>
        </svg>,
        Undo: ({size = 20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M9 14 4 9l5-5"/>
            <path d="M4 9h10.5a5.5 5.5 0 0 1 5.5 5.5v0a5.5 5.5 0 0 1-5.5 5.5H11"/>
        </svg>,
        Trophy: ({size = 20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                      strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/>
            <path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/>
            <path d="M4 22h16"/>
            <path d="M10 14.66V17"/>
            <path d="M14 14.66V17"/>
            <path d="M18 2h-5.5a5.5 5.5 0 1 0-11 0H6v7a6 6 0 0 0 12 0V2Z"/>
        </svg>,
        Play: ({size = 20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <polygon points="5 3 19 12 5 21 5 3"/>
        </svg>,
        List: ({size = 20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                    strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <line x1="8" y1="6" x2="21" y2="6"></line>
            <line x1="8" y1="12" x2="21" y2="12"></line>
            <line x1="8" y1="18" x2="21" y2="18"></line>
            <line x1="3" y1="6" x2="3.01" y2="6"></line>
            <line x1="3" y1="12" x2="3.01" y2="12"></line>
            <line x1="3" y1="18" x2="3.01" y2="18"></line>
        </svg>,
        Shield: ({size = 20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                      strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/>
        </svg>,
        Sword: ({size = 20}) => <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor"
                                     strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
            <polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5"/>
            <line x1="13" y1="19" x2="19" y2="13"/>
            <line x1="16" y1="16" x2="20" y2="20"/>
            <line x1="19" y1="21" x2="21" y2="19"/>
        </svg>
    };

    const Game = () => {
        // State
        const [board, setBoard] = React.useState(mainEngine.board);
        const [turn, setTurn] = React.useState(PIECE_B);
        const [userPlayer, setUserPlayer] = React.useState(PIECE_B);
        const [lastMove, setLastMove] = React.useState(null);
        const [winner, setWinner] = React.useState(null);
        const [winningLine, setWinningLine] = React.useState([]);
        const [thinking, setThinking] = React.useState(false);
        const [gameStarted, setGameStarted] = React.useState(false);
        const [history, setHistory] = React.useState([]);

        const [tick, setTick] = React.useState(0);
        const forceUpdate = () => setTick(t => t + 1);

        // Web Worker Ref
        const workerRef = React.useRef(null);
        // History Auto-scroll Ref
        const moveListRef = React.useRef(null);

        // =========================================================
        // === Web Worker 生命周期管理 ===
        // 只有当 gameStarted 为 true 时才创建 Worker
        // 当 gameStarted 为 false (点击结束游戏) 时立即销毁 Worker
        // =========================================================
        React.useEffect(() => {
            if (!gameStarted) {
                return;
            } // 游戏未开始，不创建 Worker

            // 1. 组装 Worker 代码
            const gameLogicScript = document.getElementById('game-logic').textContent;
            const workerHandlerCode = `
                let engine = null;

                self.onmessage = function(e) {
                    const { board, aiPlayerId, oppPlayerId, command } = e.data;

                    if (!engine) {
                        engine = new GameEngine();
                    }

                    if (command === 'THINK') {
                        engine.aiPlayerId = aiPlayerId;
                        engine.oppPlayerId = oppPlayerId;
                        engine.syncBoard(board);

                        const move = engine.determineNextPlay();
                        self.postMessage({ type: 'MOVE', move: move });
                    }
                };
            `;
            const fullWorkerCode = gameLogicScript + workerHandlerCode;
            const blob = new Blob([fullWorkerCode], {type: 'application/javascript'});
            const workerUrl = URL.createObjectURL(blob);

            // 2. 创建 Worker
            const worker = new Worker(workerUrl);
            workerRef.current = worker;

            // 3. 绑定消息接收
            worker.onmessage = (e) => {
                const {type, move} = e.data;
                if (type === 'MOVE') {
                    if (move) {
                        // 注意：这里直接调用了外部函数，生产环境建议用更严谨的状态管理
                        performMove(move.r, move.c, mainEngine.aiPlayerId);
                    }
                    setThinking(false);
                }
            };

            // 4. 清理函数 (关键点)
            return () => {
                // 当组件卸载 OR gameStarted 变为 false 时触发
                if (workerRef.current) {
                    workerRef.current.terminate(); // 立即杀掉线程
                    workerRef.current = null;
                }
                URL.revokeObjectURL(workerUrl);
                setThinking(false); // 确保 UI 不会卡在“思考中”
            };
        }, [gameStarted]); // 依赖 gameStarted，状态切换时自动重建/销毁

        React.useEffect(() => {
            if (moveListRef.current) {
                moveListRef.current.scrollTop = moveListRef.current.scrollHeight;
            }
        }, [history]);

        const startGame = (userIsBlack) => {
            mainEngine.init();
            const newUser = userIsBlack ? PIECE_B : PIECE_W;
            const newAi = userIsBlack ? PIECE_W : PIECE_B;

            mainEngine.aiPlayerId = newAi;
            mainEngine.oppPlayerId = newUser;

            setUserPlayer(newUser);
            setTurn(PIECE_B);
            setWinner(null);
            setWinningLine([]);
            setLastMove(null);
            setHistory([]);
            setBoard([...mainEngine.board]);
            // 先开启游戏状态，这将触发 useEffect 创建新的 Worker
            setGameStarted(true);
            setThinking(false);
        };

        const triggerAiMove = () => {
            if (!workerRef.current) {
                return;
            }
            setThinking(true);
            workerRef.current.postMessage({
                command: 'THINK',
                board: mainEngine.board,
                aiPlayerId: mainEngine.aiPlayerId,
                oppPlayerId: mainEngine.oppPlayerId
            });
        };

        const performMove = (r, c, player) => {
            mainEngine.boardUpdate(r, c, player);
            setHistory(prev => [...prev, {r, c, player}]);
            setLastMove({r, c});
            forceUpdate(); // 更新视图

            if (mainEngine.checkWin(r, c, player)) {
                setWinner(player);
                const winLine = mainEngine.getWinningLine(r, c, player);
                setWinningLine(winLine);
                return;
            }
            const nextTurn = player === 1 ? 2 : 1;
            setTurn(nextTurn);
        };

        React.useEffect(() => {
            if (gameStarted && !winner && turn !== userPlayer && !thinking) {
                // 给 UI 一点时间渲染 "思考中" 状态，然后触发 Worker
                // 增加一点延迟确保 workerRef 已经由 effect 创建完毕
                setTimeout(triggerAiMove, 50);
            }
        }, [turn, gameStarted, winner, userPlayer]);

        const handleCellClick = (r, c) => {
            if (!gameStarted || winner || thinking || turn !== userPlayer) {
                return;
            }
            if (mainEngine.board[r][c] !== EMPTY_SLOT) {
                return;
            }
            performMove(r, c, userPlayer);
        };

        const handleUndo = () => {
            if (thinking || !gameStarted || history.length < 2) {
                return;
            }
            if (winner) {
                return;
            }

            const aiMove = history[history.length - 1];
            const userMove = history[history.length - 2];

            mainEngine.boardUpdate(aiMove.r, aiMove.c, EMPTY_SLOT);
            mainEngine.boardUpdate(userMove.r, userMove.c, EMPTY_SLOT);

            const newHistory = history.slice(0, -2);
            setHistory(newHistory);
            setWinner(null);
            setWinningLine([]);

            if (newHistory.length > 0) {
                const prev = newHistory[newHistory.length - 1];
                setLastMove({r: prev.r, c: prev.c});
            } else {
                setLastMove(null);
            }
            forceUpdate();
        };

        const getCoordLabel = (index) => {
            return String.fromCharCode(65 + index);
        };

        return (
            <div className="flex-grow flex items-center justify-center p-4 lg:p-8">
                <div className="max-w-6xl w-full flex flex-col md:flex-row gap-8 items-stretch justify-center">

                    {/* --- 第一区域: 棋盘 --- */}
                    <div className="relative flex-shrink-0 mx-auto">
                        <div className="relative p-6 sm:p-8 rounded shadow-2xl board-texture select-none">
                            <div className="relative" style={{
                                width: 'min(85vw, 540px)',
                                height: 'min(85vw, 540px)'
                            }}>
                                <div className="absolute -top-6 left-0 w-full grid grid-cols-15"
                                     style={{gridTemplateColumns: `repeat(${BOARD_SIZE}, 1fr)`}}>
                                    {Array.from({length: 15}).map((_, i) => (
                                        <div key={i} className="flex items-center justify-center">
                                            <span className="coord-text">{getCoordLabel(i)}</span>
                                        </div>
                                    ))}
                                </div>
                                <div className="absolute top-0 -left-6 h-full grid grid-rows-15"
                                     style={{gridTemplateRows: `repeat(${BOARD_SIZE}, 1fr)`}}>
                                    {Array.from({length: 15}).map((_, i) => (
                                        <div key={i} className="flex items-center justify-end pr-1">
                                            <span className="coord-text">{i + 1}</span>
                                        </div>
                                    ))}
                                </div>

                                <div className="w-full h-full grid grid-cols-15 grid-rows-15 relative z-0"
                                     style={{
                                         display: 'grid',
                                         gridTemplateColumns: `repeat(${BOARD_SIZE}, 1fr)`,
                                         gridTemplateRows: `repeat(${BOARD_SIZE}, 1fr)`
                                     }}>
                                    {Array.from({length: BOARD_SIZE * BOARD_SIZE}).map((_, i) => {
                                        const r = Math.floor(i / BOARD_SIZE);
                                        const c = i % BOARD_SIZE;
                                        const isTop = r === 0;
                                        const isBottom = r === BOARD_SIZE - 1;
                                        const isLeft = c === 0;
                                        const isRight = c === BOARD_SIZE - 1;
                                        const isStar = (r === 3 && c === 3) || (r === 3 && c === 11) ||
                                            (r === 11 && c === 3) || (r === 11 && c === 11) ||
                                            (r === 7 && c === 7);
                                        const moveIndex = history.findIndex(m => m.r === r && m.c === c);
                                        const moveNumber = moveIndex !== -1 ? moveIndex + 1 : null;
                                        const isWinningPiece = winningLine.some(p => p.r === r && p.c === c);

                                        return (
                                            <div key={i}
                                                 onClick={() => handleCellClick(r, c)}
                                                 className="relative cursor-pointer z-10 outline-none tap-highlight-transparent"
                                            >
                                                <div
                                                    className={`absolute bg-[#5c4033] opacity-80 ${isTop ? 'top-1/2 h-1/2' : isBottom ? 'h-1/2' : 'h-full'} left-1/2 w-[1px] -translate-x-1/2`}></div>
                                                <div
                                                    className={`absolute bg-[#5c4033] opacity-80 ${isLeft ? 'left-1/2 w-1/2' : isRight ? 'w-1/2' : 'w-full'} top-1/2 h-[1px] -translate-y-1/2`}></div>
                                                {isStar && <div
                                                    className="absolute top-1/2 left-1/2 w-1.5 h-1.5 bg-[#4a2c20] rounded-full -translate-x-1/2 -translate-y-1/2 shadow-sm z-0"></div>}
                                                {mainEngine.board[r][c] !== EMPTY_SLOT && (
                                                    <div
                                                        className={`piece piece-enter ${mainEngine.board[r][c] === PIECE_B ? 'piece-black' : 'piece-white'} ${isWinningPiece ? 'piece-win ring-4 ring-green-500 scale-105' : (winner ? 'opacity-70 grayscale-[0.3]' : '')}`}>
                                                        {moveNumber && <span>{moveNumber}</span>}
                                                        {lastMove && lastMove.r === r && lastMove.c === c && !isWinningPiece && (
                                                            <div
                                                                className="absolute w-full h-full rounded-full ring-2 ring-red-500/80 animate-pulse"></div>
                                                        )}
                                                    </div>
                                                )}
                                                {!winner && !thinking && gameStarted && turn === userPlayer && mainEngine.board[r][c] === EMPTY_SLOT && (
                                                    <div
                                                        className={`absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 w-[80%] h-[80%] rounded-full opacity-0 hover:opacity-40 transition-opacity duration-200 ${userPlayer === PIECE_B ? 'bg-black' : 'bg-white'}`}></div>
                                                )}
                                            </div>
                                        );
                                    })}
                                </div>
                            </div>
                        </div>
                    </div>

                    {/* --- 第二区域: 状态控制面板 --- */}
                    <div className="flex-1 max-w-sm w-full mx-auto md:mx-0 flex flex-col gap-5">
                        <div className="text-center md:text-left space-y-1">
                            <h1 className="text-4xl font-black italic tracking-tighter bg-gradient-to-r from-blue-400 via-purple-400 to-pink-400 bg-clip-text text-transparent drop-shadow-sm">GOMOKU</h1>
                            <div className="flex items-center justify-center md:justify-start gap-3">
                                <span
                                    className="text-[10px] font-bold px-2 py-0.5 rounded bg-blue-500/20 text-blue-300 border border-blue-500/30">ALPHA-BETA</span>
                                <span
                                    className="text-[10px] font-bold px-2 py-0.5 rounded bg-purple-500/20 text-purple-300 border border-purple-500/30">DEPTH {SEARCH_DEPTH}</span>
                            </div>
                        </div>

                        {gameStarted ? (
                            <div className="flex flex-col gap-4 animate-fade-in flex-grow">
                                <div
                                    className="glass-panel rounded-2xl p-1 flex items-stretch h-24 relative overflow-hidden">
                                    <div
                                        className={`flex-1 flex flex-col items-center justify-center gap-1 rounded-xl transition-all duration-300 relative z-10 ${turn === userPlayer && !winner ? 'bg-indigo-500/20 shadow-[inset_0_0_20px_rgba(99,102,241,0.2)]' : ''}`}>
                                        <div className="relative">
                                            <div
                                                className={`w-10 h-10 rounded-full flex items-center justify-center border-2 ${userPlayer === PIECE_B ? 'bg-gray-900 border-gray-600' : 'bg-gray-100 border-white'}`}>
                                                <Icons.User size={20}
                                                            className={userPlayer === PIECE_B ? 'text-gray-400' : 'text-gray-500'}/>
                                            </div>
                                            {turn === userPlayer && !winner && <div
                                                className="absolute inset-0 rounded-full animate-pulse-ring"></div>}
                                        </div>
                                        <div className="text-xs font-bold text-slate-300">YOU</div>
                                        <div
                                            className={`text-[10px] font-mono px-1.5 rounded ${userPlayer === PIECE_B ? 'bg-black text-white' : 'bg-white text-black'}`}>
                                            {userPlayer === PIECE_B ? 'BLACK' : 'WHITE'}
                                        </div>
                                    </div>
                                    <div className="w-12 flex flex-col items-center justify-center relative z-10">
                                        <span className="text-2xl font-black text-white/10 italic">VS</span>
                                    </div>
                                    <div
                                        className={`flex-1 flex flex-col items-center justify-center gap-1 rounded-xl transition-all duration-300 relative z-10 ${turn !== userPlayer && !winner ? 'bg-pink-500/20 shadow-[inset_0_0_20px_rgba(236,72,153,0.2)]' : ''}`}>
                                        <div className="relative">
                                            <div
                                                className={`w-10 h-10 rounded-full flex items-center justify-center border-2 ${userPlayer !== PIECE_B ? 'bg-gray-900 border-gray-600' : 'bg-gray-100 border-white'}`}>
                                                <Icons.Cpu size={20}
                                                           className={userPlayer !== PIECE_B ? 'text-gray-400' : 'text-gray-500'}/>
                                            </div>
                                            {(turn !== userPlayer && !winner) || thinking ? <div
                                                className="absolute inset-0 rounded-full animate-pulse-ring"></div> : null}
                                        </div>
                                        <div className="text-xs font-bold text-slate-300">AI ENGINE</div>
                                        <div
                                            className={`text-[10px] font-mono px-1.5 rounded ${userPlayer !== PIECE_B ? 'bg-black text-white' : 'bg-white text-black'}`}>
                                            {userPlayer !== PIECE_B ? 'BLACK' : 'WHITE'}
                                        </div>
                                    </div>
                                    <div
                                        className={`absolute top-0 bottom-0 w-1/2 transition-all duration-500 ease-in-out bg-gradient-to-b from-white/5 to-transparent ${turn === userPlayer ? 'left-0' : 'left-1/2'}`}></div>
                                </div>

                                <div
                                    className="h-12 flex items-center justify-center glass-panel rounded-xl border-l-4 overflow-hidden shadow-lg transition-all duration-300"
                                    style={{borderColor: winner ? (winner === userPlayer ? '#4ADE80' : '#F87171') : (thinking ? '#F472B6' : '#818CF8')}}>
                                    {winner ? (
                                        <div className="flex items-center gap-3 animate-bounce">
                                            <Icons.Trophy
                                                className={winner === userPlayer ? "text-green-400" : "text-red-400"}
                                                size={24}/>
                                            <span
                                                className={`text-lg font-bold ${winner === userPlayer ? "text-green-100" : "text-red-100"}`}>
                                                {winner === userPlayer ? "胜利！WINNER" : "AI 获胜 DEFEAT"}
                                            </span>
                                        </div>
                                    ) : thinking ? (
                                        <div className="flex items-center gap-3">
                                            <div
                                                className="w-5 h-5 border-2 border-pink-400 border-t-transparent rounded-full animate-spin"></div>
                                            <span className="font-mono text-pink-200 font-bold tracking-widest">AI THINKING...</span>
                                        </div>
                                    ) : (
                                            <div className="flex items-center gap-2">
                                            <span className="relative flex h-3 w-3">
                                              <span
                                                  className="animate-ping absolute inline-flex h-full w-full rounded-full bg-indigo-400 opacity-75"></span>
                                              <span
                                                  className="relative inline-flex rounded-full h-3 w-3 bg-indigo-500"></span>
                                            </span>
                                                <span className="text-indigo-100 font-bold text-sm tracking-wide">YOUR TURN</span>
                                            </div>
                                        )}
                                </div>

                                <div className="glass-panel rounded-xl flex flex-col overflow-hidden h-64 shrink-0">
                                    <div
                                        className="bg-slate-900/40 px-4 py-2 flex items-center justify-between border-b border-white/5">
                                        <div
                                            className="flex items-center gap-2 text-[10px] font-bold text-slate-400 uppercase tracking-wider">
                                            <Icons.List size={12}/> Move History
                                        </div>
                                        <span
                                            className="text-[10px] font-mono text-slate-500">TTL: {history.length}</span>
                                    </div>
                                    <div ref={moveListRef}
                                         className="flex-grow overflow-y-auto p-0 custom-scrollbar bg-slate-900/20 font-mono text-xs">
                                        {history.length === 0 ? (
                                            <div
                                                className="h-full flex flex-col items-center justify-center opacity-30 space-y-2">
                                                <div
                                                    className="w-8 h-8 border-2 border-dashed rounded-full animate-spin-slow"></div>
                                                <span>WAITING FOR START...</span>
                                            </div>
                                        ) : (
                                             <table className="w-full text-left border-collapse">
                                                 <thead
                                                     className="bg-white/5 text-slate-500 sticky top-0 backdrop-blur-sm">
                                                 <tr>
                                                     <th className="px-4 py-1 font-normal w-12">#</th>
                                                     <th className="px-2 py-1 font-normal">SIDE</th>
                                                     <th className="px-4 py-1 font-normal text-right">COORD</th>
                                                 </tr>
                                                 </thead>
                                                 <tbody>
                                                 {history.map((move, index) => (
                                                     <tr key={index}
                                                         className={`border-b border-white/5 hover:bg-white/5 transition-colors ${index === history.length - 1 ? 'bg-indigo-500/10' : ''}`}>
                                                         <td className="px-4 py-2 text-slate-500">{index + 1 < 10 ? `0${index + 1}` : index + 1}</td>
                                                         <td className="px-2 py-2">
                                                             <span
                                                                 className={`inline-block w-2 h-2 rounded-full mr-2 ${move.player === PIECE_B ? 'bg-black shadow-[0_0_5px_rgba(0,0,0,0.8)]' : 'bg-white shadow-[0_0_5px_rgba(255,255,255,0.8)]'}`}></span>
                                                             <span
                                                                 className={move.player === PIECE_B ? 'text-slate-400' : 'text-slate-200'}>
                                                                    {move.player === PIECE_B ? 'BLK' : 'WHT'}
                                                                </span>
                                                         </td>
                                                         <td className="px-4 py-2 text-right font-bold text-blue-200">
                                                             {getCoordLabel(move.c)}{move.r + 1}
                                                         </td>
                                                     </tr>
                                                 ))}
                                                 </tbody>
                                             </table>
                                         )}
                                    </div>
                                </div>

                                <div className="grid grid-cols-2 gap-4 mt-auto">
                                    <button onClick={handleUndo} disabled={winner || thinking || history.length < 2}
                                            className="group relative flex items-center justify-center gap-2 py-3.5 rounded-xl bg-slate-800/80 hover:bg-slate-700 text-slate-300 disabled:opacity-40 disabled:cursor-not-allowed transition-all border border-white/10 shadow-lg overflow-hidden">
                                        <div
                                            className="absolute inset-0 bg-white/5 translate-y-full group-hover:translate-y-0 transition-transform"></div>
                                        <Icons.Undo size={18}/>
                                        <span className="font-bold text-sm relative z-10">悔棋 UNDO</span>
                                    </button>
                                    {/* 点击结束后，setGameStarted(false) 会触发 useEffect 的 cleanup，立即终止 Worker */}
                                    <button onClick={() => setGameStarted(false)}
                                            className="group relative flex items-center justify-center gap-2 py-3.5 rounded-xl bg-gradient-to-r from-red-900/80 to-red-800/80 hover:from-red-800 hover:to-red-700 text-red-100 transition-all border border-red-500/30 shadow-lg shadow-red-900/20 overflow-hidden">
                                        <div
                                            className="absolute inset-0 bg-white/10 opacity-0 group-hover:opacity-100 transition-opacity"></div>
                                        <Icons.Refresh size={18}/>
                                        <span className="font-bold text-sm relative z-10">结束 END</span>
                                    </button>
                                </div>
                            </div>
                        ) : (
                             <div
                                 className="glass-panel rounded-2xl p-6 flex flex-col gap-5 shadow-2xl animate-fade-in mt-4">
                                 <div>
                                     <h2 className="text-xl font-bold text-white mb-1">开始新对局</h2>
                                     <p className="text-sm text-slate-400">选择您要执的棋子颜色</p>
                                 </div>
                                 <button onClick={() => startGame(true)}
                                         className="group relative w-full p-5 rounded-xl bg-gradient-to-br from-slate-800 via-slate-900 to-black border border-slate-700 hover:border-indigo-500 hover:shadow-[0_0_20px_rgba(99,102,241,0.3)] transition-all text-left overflow-hidden">
                                     <div
                                         className="absolute top-0 right-0 p-3 opacity-10 group-hover:opacity-20 group-hover:scale-110 transition-all">
                                         <Icons.Sword size={60}/>
                                     </div>
                                     <div className="flex items-center justify-between relative z-10">
                                         <div className="flex items-center gap-4">
                                             <div
                                                 className="w-10 h-10 rounded-full bg-black shadow-[0_0_15px_rgba(0,0,0,0.8)] border border-slate-700 ring-2 ring-transparent group-hover:ring-indigo-500/50 transition-all flex items-center justify-center">
                                                 <span className="text-[10px] text-gray-500 font-bold">先</span>
                                             </div>
                                             <div>
                                                 <div
                                                     className="font-bold text-lg text-white group-hover:text-indigo-300 transition-colors">执黑
                                                     (先手)
                                                 </div>
                                                 <div className="text-xs text-slate-400 font-mono mt-1">进攻型策略 /
                                                     ATK
                                                 </div>
                                             </div>
                                         </div>
                                     </div>
                                 </button>
                                 <button onClick={() => startGame(false)}
                                         className="group relative w-full p-5 rounded-xl bg-gradient-to-br from-slate-100 via-slate-200 to-slate-300 border border-white hover:border-indigo-500 hover:shadow-[0_0_20px_rgba(99,102,241,0.3)] transition-all text-left overflow-hidden">
                                     <div
                                         className="absolute top-0 right-0 p-3 opacity-10 group-hover:opacity-20 group-hover:scale-110 transition-all">
                                         <Icons.Shield size={60} className="text-slate-900"/>
                                     </div>
                                     <div className="flex items-center justify-between relative z-10">
                                         <div className="flex items-center gap-4">
                                             <div
                                                 className="w-10 h-10 rounded-full bg-white shadow-[0_0_15px_rgba(255,255,255,0.6)] border border-slate-200 ring-2 ring-transparent group-hover:ring-indigo-500/50 transition-all flex items-center justify-center">
                                                 <span className="text-[10px] text-gray-400 font-bold">后</span>
                                             </div>
                                             <div>
                                                 <div
                                                     className="font-bold text-lg text-slate-900 group-hover:text-indigo-700 transition-colors">执白
                                                     (后手)
                                                 </div>
                                                 <div className="text-xs text-slate-600 font-mono mt-1">防守反击 / DEF
                                                 </div>
                                             </div>
                                         </div>
                                     </div>
                                 </button>
                                 <div className="mt-2 pt-4 border-t border-white/5 text-center">
                                     <p className="text-[10px] text-slate-500 font-mono">POWERED BY MINIMAX ENGINE</p>
                                 </div>
                             </div>
                         )}
                    </div>
                </div>
            </div>
        );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<Game/>);
</script>
</body>
</html>
